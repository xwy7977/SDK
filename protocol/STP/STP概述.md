[原文地址https://info.support.huawei.com/info-finder/encyclopedia/zh/STP.html](https://info.support.huawei.com/info-finder/encyclopedia/zh/STP.html)

# 什么是STP

STP（Spanning Tree Protocol）是一个用于局域网中消除环路的协议，它的标准是IEEE 802.1D。STP通过将部分冗余链路强制为阻塞状态，其他链路处于转发状态，将环形网络结构修剪成无环路的树形网络结构，可实现消除环路。当处于转发状态的链路不可用时，STP重新配置网络，并激活合适的备用链路状态，恢复恢复网络连通性。

# 为什么需要STP

在一个复杂的网络环境中，由于冗余备份的需要，网络设计者都倾向于在设备之间部署多条物理链路，其中一条作主用链路，其他链路作备份，偶然或必然中都会导致环路产生。环路会产生广播风暴，最终导致整个网络资源被耗尽，网络瘫痪不可用。环路还会引起MAC地址表震荡导致MAC地址表项被破坏。

STP技术可以有效的解决环路问题，将彼此交互信息发现网络中的环路，将部分冗余链路强制为阻塞状态，其他链路处于转发状态。最终将环形网络结构修剪成无环路的树形网络结构，从而防止报文在环形网络中不断增生和无限循环，避免设备由于重复接收相同的报文造成处理能力下降。

# STP vs RSTP vs MSTP

STP包含两种含义：

- 狭义的STP是指IEEE 802.1D中定义的STP协议。
- 广义的STP包括IEEE 802.1D中定义的STP、IEEE 802.1W中定义的快速生成树协议RSTP（Rapid Spanning Tree Protocol）和IEEE 802.1S中定义的多生成树协议MSTP（Multiple Spanning Tree Protocol）。

目前，生成树协议支持如下：

- STP是基础的数据链路层的管理协议，用于二层网络的环路检测和预防。但是，STP拓扑收敛速度慢。
- RSTP在STP基础上进行了改进，实现了网络拓扑快速收敛。但RSTP和STP还存在同一个缺陷：局域网内所有的VLAN共享一棵生成树，不能按VLAN阻塞冗余链路，所有VLAN的报文都沿着一棵生成树进行转发。
- MSTP通过设置VLAN映射表（即VLAN和生成树实例的对应关系表），把VLAN和生成树实例联系起来。同时它把一个交换网络划分成多个域，每个域内形成多棵生成树实例，生成树实例之间彼此独立。MSTP提供了数据转发的多个冗余路径，在数据转发过程中实现VLAN数据的负载均衡。

生成树协议中，MSTP兼容RSTP、STP，RSTP兼容STP。三种生成树协议的比较如下表所示。

| **生成树协议** | **特点**                                                     | 应用场景                                                     |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| STP            | 形成一棵无环路的树，解决广播风暴并实现冗余备份。收敛速度较慢。 | 无需区分用户或业务流量，所有VLAN共享一棵生成树。             |
| RSTP           | 形成一棵无环路的树，解决广播风暴并实现冗余备份。 收敛速度快。 |                                                              |
| MSTP           | 形成多棵无环路的树，解决广播风暴并实现冗余备份。  收敛速度快。 多棵生成树在VLAN间实现负载均衡，不同VLAN的流量按照不同的路径转发。 | 需要区分用户或业务流量，并实现负载分担。不同的VLAN通过不同的生成树转发流量，每棵生成树之间相互独立。 |

# STP是如何工作的

## STP的基本概念

从环形网络拓扑结构到树形结构，总体来说有三个要素：根桥、根端口和指定端口。

**根桥**：对于一个STP网络，根桥在全网中只有一个，它是整个网络的逻辑中心，但不一定是物理中心。在进行根桥的选择时，一般会选择性能高、网络层次高的交换设备作为根桥。根桥会根据网络拓扑的变化而动态变化。

**根端口**：去往根桥路径开销最小的端口，根端口负责向根桥方向转发数据，这个端口的选择标准是依据路径开销判定。在一台设备上所有使能STP的端口中，根路径开销最小者，就是根端口。很显然，在一个运行STP协议的设备上根端口有且只有一个，根桥上没有根端口。

**指定端口**：指定桥与指定端口的描述见下表。

| **分类**           | **指定桥**                                     | **指定端口**                     |
| ------------------ | ---------------------------------------------- | -------------------------------- |
| 对于一台设备而言   | 与本机直接相连并且负责向本机转发配置消息的设备 | 指定桥向本机转发配置消息的端口   |
| 对于一个局域网而言 | 负责向本网段转发配置消息的设备                 | 指定桥向本网段转发配置消息的端口 |

如下图所示，AP1、AP2、BP1、BP2、CP1、CP2分别表示设备Device1、Device2、Device3的端口。

![指定桥与指定端口示意图](./STP概述.assets/01.png)

- Device1通过端口AP1向Device2转发配置消息，则Device2的指定桥就是Device1，指定端口就是Device1的端口AP1。
- 与局域网LAN相连的有两台设备：Device2和Device3，如果Device2负责向LAN转发配置消息，则LAN的指定桥就是Device2，指定端口就是Device2的BP2。

此外，设备和端口都有ID，分别是桥ID（BID）和端口ID（PID）。端口ID由端口优先级和端口号组成。桥ID由桥优先级和桥MAC两部分组成，在STP网络中，桥ID最小的设备会被选举为根桥。

## STP的实现过程

STP的基本实现过程如下：

1. 选择根网桥：网络初始化时，网络中所有的STP设备都认为自己是“根桥”，根桥ID为自身的设备ID。通过交换BPDU消息，设备之间比较根桥ID，网络中根桥ID最小的设备被选为根桥。根桥上的所有端口都是转发状态。

2. 选择根端口：非根桥设备将接收最优配置消息的那个端口定为根端口，根端口也是处于转发状态。

3. 选择指定端口：设备根据根端口的配置消息和根端口的路径开销，为每个端口计算一个指定端口配置消息，然后将计算出的配置消息与角色待定端口自己的配置消息进行比较。
    * 如果计算出的配置消息更优，则该端口被确定为指定端口，其配置消息也被计算出的配置消息替换，并周期性地向外发送；

    * 如果该端口自己的配置消息更优，则不更新该端口的配置消息并将该端口阻塞。该端口将不再转发数据，且只接收不发送配置消息。

一旦根桥、根端口和指定端口选举成功，整个树形拓扑就建立完毕了。在拓扑稳定后，只有根端口和指定端口转发流量，其他的非根、非指定端口都处于阻塞（Blocking）状态，它们只接收STP协议报文而不转发用户流量。下面结合例子说明STP算法实现的具体过程。

![STP算法实现过程组网图及计算后的拓扑](./STP概述.assets/02.png)

如上图所示，DeviceA、DeviceB和DeviceC的优先级分别为0、1和2，DeviceA与DeviceB之间、DeviceA与DeviceC之间以及DeviceB与DeviceC之间链路的路径开销分别为5、10和4。

**1. 各设备的初始状态**

各设备的初始状态如表1-3所示。

表1-3 各设备的初始状态

| **设备**           | **端口名称**                                     | **端口的配置消息**                |
| ------------------ | ----------------------------------------------- | -------------------------------- |
| DeviceA            | Port A1                                        | {0，0，0，Port A1}                |
| DeviceA            | Port A2                                        | {0，0，0，Port A2}                |
| DeviceB            | Port B1                                        | {0，0，0，Port B1}                |
| DeviceB            | Port B2                                        | {0，0，0，Port B2}                |
| DeviceC            | Port C1                                        | {0，0，0，Port C1}                |
| DeviceC            | Port C2                                        | {0，0，0，Port C2}                |

**2. 各设备的比较过程及结果**

各设备的比较过程及结果如下所示，配置消息中各项的具体含义为：{根桥ID，累计根路径开销，发送者BID，发送端口PID}。

DeviceA比较过程

1. Port A1收到Port B1的配置消息{1，0，1，Port B1}，发现自己的配置消息{0，0，0，Port A1}更优，于是将其丢弃。
2. Port A2收到Port C1的配置消息{2，0，2，Port C1}，发现自己的配置消息{0，0，0，Port A2}更优，于是将其丢弃。
3. DeviceA发现自己各端口的配置消息中的根桥和指定桥都是自己，于是认为自己就是根桥，各端口的配置消息都不作任何修改，此后便周期性地向外发送配置消息。

DeviceA比较后端口的配置消息

1. Port A1：{0，0，0，Port A1}
2. Port A2：{0，0，0，Port A2}

DeviceB比较过程

1. Port B1收到Port A1的配置消息{0，0，0，Port A1}，发现其比自己的配置消息{1，0，1，Port B1}更优，于是更新自己的配置消息。
2. Port B2收到Port C2的配置消息{2，0，2，Port C2}，发现自己的配置消息{1，0，1，Port B2}更优，于是将其丢弃。

3. DeviceB比较自己各端口的配置消息，发现Port B1的配置消息最优，于是该端口被确定为根端口，其配置消息不变。
4. DeviceB根据根端口的配置消息和路径开销，为Port B2计算出指定端口的配置消息{0，5，1，Port B2}，然后与Port B2本身的配置消息{1，0，1，Port B2}进行比较，发现计算出的配置消息更优，于是Port B2被确定为指定端口，其配置消息也被替换为计算出的配置消息，并周期性地向外发送。

DeviceB比较后端口的配置消息

1. Port B1：{0，0，0，Port A1}
2. Port B2：{1，0，1，Port B2}

3. 根端口Port B1：{0，0，0，Port A1}
4. 指定端口Port B2：{0，5，1，Port B2}

DeviceC比较过程

1. Port C1收到Port A2的配置消息{0，0，0，Port A2}，发现其比自己的配置消息{2，0，2，Port C1}更优，于是更新自己的配置消息。
2. Port C2收到Port B2更新前的配置消息{1，0，1，Port B2}，发现其比自己的配置消息{2，0，2，Port C2}更优，于是更新自己的配置消息。

3. DeviceC比较自己各端口的配置消息，发现Port C1的配置消息最优，于是该端口被确定为根端口，其配置消息不变。
4. DeviceC根据根端口的配置消息和路径开销，为Port C2计算出指定端口的配置消息{0，10，2，Port C2}，然后与Port C2本身的配置消息{1，0，1，Port B2}进行比较，发现计算出的配置消息更优，于是Port C2被确定为指定端口，其配置消息也被替换为计算出的配置消息。

5. Port C2收到Port B2更新后的配置消息{0，5，1，Port B2}，发现其比自己的配置消息{0，10，2，Port C2}更优，于是更新自己的配置消息。
6. Port C1收到Port A2周期性发来的配置消息{0，0，0，Port A2}，发现其与自己的配置消息一样，于是将其丢弃。

7. DeviceC比较Port C1的根路径开销10（收到的配置消息中的根路径开销0＋本端口所在链路的路径开销10）与Port C2的根路径开销9（收到的配置消息中的根路径开销5＋本端口所在链路的路径开销4），发现后者更小，因此Port C2的配置消息更优，于是Port C2被确定为根端口，其配置消息不变。
8. DeviceC根据根端口的配置消息和路径开销，为Port C1计算出指定端口的配置消息{0，9，2，Port C1}，然后与Port C1本身的配置消息{0，0，0，Port A2}进行比较，发现本身的配置消息更优，于是Port C1被阻塞，其配置消息不变。从此，Port C1不再转发数据，直至有触发生成树计算的新情况出现，譬如DeviceB与DeviceC之间的链路down掉。

DeviceC比较后端口的配置消息

1. Port C1：{0，0，0，Port A2}
2. Port C2：{1，0，1，Port B2}

3. 根端口Port C1：{0，0，0，Port A2}
4. 指定端口Port C2：{0，10，2，Port C2}

5. Port C1：{0，0，0，Port A2}
6. Port C2：{0，5，1，Port B2}

7. 阻塞端口Port C1：{0，0，0，Port A2}
8. 根端口Port C2：{0，5，1，Port B2}

拓扑稳定后，根桥仍然按照Hello Timer规定的时间间隔发送配置BPDU报文，非根桥设备从根端口收到配置BPDU报文，通过指定端口转发。如果接收到的优先级比自己高的配置BPDU，则非根桥设备会根据收到的配置BPDU中携带的信息更新自己相应的端口存储的配置BPDU信息。

## STP的典型应用

在一个复杂的网络中，网络规划者由于冗余备份的需要，一般都倾向于在设备之间部署多条物理链路，其中一条作主用链路，其他链路作备份。这样就难免会形成环形网络，若网络中存在环路，可能会引起广播风暴和MAC表项被破坏。

如下图所示，在网络中部署STP协议，通过彼此交互信息发现网络中的环路，并有选择的对某个端口进行阻塞，最终将环形网络结构修剪成无环路的树形网络结构，从而防止报文在环形网络中不断增生和无限循环，避免设备由于重复接收相同的报文造成处理能力下降。

![STP典型应用组网图](./STP概述.assets/03.png)